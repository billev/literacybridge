// Copyright 2009,2010 Literacy Bridge
// CONFIDENTIAL -- Do not share without Literacy Bridge Non-Disclosure Agreement
// Contact: info@literacybridge.org

#define PCBTESTS


#include "./Application\TalkingBook\Include\device.h"
#include "./Application\TalkingBook\Include\SD_reprog.h"
#include "./Application\TalkingBook\Include\audio.h"

void Check_flash_reprog();
static void NewCurrent();
void FlashReprogHimem(flash *fp);
void FlashReprogLomem(flash *fp, unsigned int *);

int ReprogFlash(flash *);

void Try_SD_reprog(flash *fp) {
	
	NewCurrent ();  // make attempted firmware current firmware file
	FlashReprogHimem(fp);
}

void
FlashReprogHimem(flash *fp) {
	int i, nbytes, nwords;
	unsigned int buf[FLASH_SD_READ_SIZE], *addr;
	long pos;
	extern void FlashReprogLomem();
	unsigned int offset = 0;
	
	pos = lseek(fp->fileHandle, 0xa8000 * 2, SEEK_SET);
	
	fp->pflash = 0x70000; // erase 0x70000
	fp->erasesector(fp);

	for (addr = (void *)0xa8000; (unsigned long)addr < (unsigned long)ENDADDR; addr += FLASH_SD_READ_SIZE) {
		nbytes = read(fp->fileHandle, (unsigned long)buf<<1, FLASH_SD_READ_SIZE<<1);
		if(nbytes <= 0)
			break;
		
		nwords = nbytes >> 1;
		
		fp->pflash = addr;
		
		for(i=0; i<nwords; i++) {
			if(buf[i] == 0xffff)
				continue;
			(*fp->writeword)(fp, 0x70000 + i + offset, buf[i]);
	    }
	    offset += nwords;
	}
	
	
	fp->pflash = 0xb0000;
	copy70000(fp);
	
	FlashReprogLomem(fp, buf);	

}
static void
copy70000(flash *fp) {
	unsigned long i;
	unsigned int *addr;
	unsigned int *buf = (unsigned int *) 0x70000;
	
	fp->pflash = fp->pflash - (unsigned)FLASH_ERASE_SIZE;
	if(fp->pflash == 0x70000)
		return;
	
	fp->erasesector(fp);
	
	for(i=0, addr = fp->pflash; i < (unsigned)FLASH_ERASE_SIZE; i++) {
		if(buf[i] == 0xffff)
			continue;		
		(*fp->writeword)(fp, addr + i, buf[i]);
    }

}

static void
NewCurrent() {
	int ret;
	struct f_info file_info;
	char filename[40];
	
	ret = chdir((LPSTR)FIRMWARE_PATH);
	ret =_findfirst((LPSTR)"*" PREV_EXT, &file_info, D_FILE);
	if (ret >= 0) 
		ret = unlink((LPSTR)file_info.f_name);	
	ret =_findfirst((LPSTR)UPDATE_FN, &file_info, D_FILE);
	if (ret >= 0) {
#ifdef PCBTESTS
		//CHANGE MADE BELOW JUST FOR PCB TESTS: 
		strcpy(filename,UPDATE_FP);
		strcat(filename,file_info.f_name);
#else
		strcpy(filename,file_info.f_name);
		strcat(filename,PREV_EXT);		
#endif		
		rename((LPSTR)file_info.f_name,(LPSTR)filename);
	}
	// move Attempt to Current
	ret =_findfirst((LPSTR)"*" ATTEMPTED_EXT, &file_info, D_FILE);
	if (ret >=0) {
		strcpy(filename,file_info.f_name);
		filename[strlen(filename)-strlen(ATTEMPTED_EXT)] = 0;
		rename((LPSTR)file_info.f_name,(LPSTR)filename);
	}
}

/*
void
ReprogFailed(flash *fp)
{
	int i;
	
	// move Attempt to Bad if Attempt exists
	fp->ret = open((LPSTR)(ATTEMPTED_FN),O_RDONLY);
	if(fp->ret >= 0) {
		close(fp->ret);
		fp->ret = unlink(BAD_FN);
		fp->ret = rename(ATTEMPTED_FN, BAD_FN);
	}
	
	// reprog with Current
	fp->fileHandle = open((LPSTR)(CURRENT_FN),O_RDONLY);
	if(fp->fileHandle < 0) {
		if(fp->prev_tries++ == 0) {	// first time ??
			_copy(PREV_FN , CURRENT_FN);
		}
	}
	fp->fileHandle = open((LPSTR)(CURRENT_FN),O_RDONLY);
	if(fp->fileHandle < 0) {
		// we are toast, recover vis usb
		return;
	}
	
	for(i = 0; i < 3; i++) {

//			fp->ret = FlashReprog(fp);
		fp->ret = (*fp->flashreprog)(fp);
		if((fp->flash_err == 0) && (fp->ckerr == 0)) {
			//
			// jump to hardware rest vector reset
			//
		}
	}
}
*/

void check_new_sd_flash() {
	struct f_info file_info;
	int ret;
		
	ret =_findfirst((LPSTR)UPDATE_FP UPDATE_FN, &file_info, D_FILE);
	if (ret < 0)
		file_info.f_name[0] = 0;
	startUpdate(file_info.f_name);
}

void startUpdate(char *filenameUpdate) {
	int ret;
	flash  FL = {0};
	int fl_size = USB_Flash_init((flash *)0, 0);
	int flash_execution_buf[fl_size];
	char oldPath[60], newPath[60];
	struct f_info file_info;
	
	// if following file exists reprogram the flash with it
	// rename the above to Attempted during reprogramming (the file has neither succeeded or failed)
	// if Attempted exists at powerup reprogramming was interrupted so reprogram Attempted again
	//   (until it succeeds or fails)
	// upon successful reprogramming move Current to Prev, Attempted to Current
	
    // be sure FIRMWARE_PATH exists
	ret = mkdir((LPSTR)FIRMWARE_PATH); // TODO:need to create higher directories if don't exist, including top-level
//	if (ret >= 0)
//		playDings(3);
//	else
//		playBips(3);	
	// see if new image file exists or was attempted
	if(filenameUpdate[0] != 0) {  // assumes only one version in update location
		strcpy(oldPath,UPDATE_FP);
		strcat(oldPath,filenameUpdate);
		strcpy(newPath,FIRMWARE_PATH);
		strcat(newPath,filenameUpdate);
		strcat(newPath,ATTEMPTED_EXT);
		
		ret = rename((LPSTR)oldPath, (LPSTR)newPath);   
		FL.fileHandle = open((LPSTR)newPath,O_RDONLY);
	} else {
		ret =_findfirst((LPSTR)FIRMWARE_PATH "*" ATTEMPTED_EXT, &file_info, D_FILE);		
		if (ret >= 0) {
			strcpy(oldPath,FIRMWARE_PATH);
			strcat(oldPath,file_info.f_name);
			FL.fileHandle = open((LPSTR)oldPath,O_RDONLY);		
		} else
			FL.fileHandle = -1;
	}
	if(FL.fileHandle < 0)
			return;	// no bin file in update, return
	playBips(2);
	setLED(LED_RED,TRUE);
	
	//commenting these two lines out since we want reprogramming to happen before config file loading where log filename is given
	//strcpy(strLog, "Reprogramming with new firmware update");	
	//logString(strLog, ASAP);

	FL.flash_exe_buf = (void *) &flash_execution_buf[0];
	USB_Flash_init(&FL, 1);

	Try_SD_reprog(&FL);
	setLED(LED_RED,FALSE);

	__asm__("irq on");
	__asm__("fiq on");

}

