#include "./system/include/system_head.h"
#include "./driver/include/driver_head.h"
#include "./component/include/component_head.h"
#include "Include/talkingbook.h"
#include "Include/files.h"
#include "Include/device.h"
#include "Include/containers.h"
#include "Include/audio.h"

static int getFileHandle (CtnrFile *);
static void playLongInt(CtnrFile *, unsigned long);
static int recordAudio(char *);
static char lastFilenameRecorded[40];

void stop(void) {
	context.isStopped = TRUE;
	Snd_Stop();
	if (GREEN_LED_WHEN_PLAYING)	
		setLED(LED_GREEN,FALSE);
	flushLog();
}

static int getFileHandle (CtnrFile *newFile) {
	int pkgType, idxList, ret = 0; 
	ListItem *list;
	char sTemp[50];
	BOOL isPackageTitle = FALSE;
	BOOL getLastRecording = FALSE;
	CtnrPackage *pkg;
		
	pkg = getPackageFromFile(newFile); // get package that applied to file, rather than context package
	// This is necessary for user packages inserting system sounds.

	// check for list
	if (newFile->idxFirstBlockInFile < -1) {
		idxList = -newFile->idxFirstBlockInFile - 2;  // weird offset to allow for future -1 for File with no Block
		list = &context.package->lists[idxList];
		isPackageTitle = (list->listType == LIST_OF_PACKAGES);
		if (isPackageTitle) {
			ret = tbChdir((unsigned long)(USER_PATH));
			//strcpy(sTemp,context.package->strHeapStack + newFile->idxFilename);
			//ret = tbChdir((unsigned long)sTemp);			
		} else
			ret = tbChdir((unsigned long)(LIST_PATH));
	// check for last file recorded (parsed from $L)
	} else if (newFile->idxFilename == -1) {  // use last file recorded
		logException(0,0,USB_MODE); // this should never happen -- removed this feature
		//getLastRecording = TRUE;
		//ret = tbChdir((unsigned long)(DRAFT_PATH));
	} // not a list or last recording; just a normal file
	else {	
		pkgType = pkg->pkg_type;
		// chdir to dir that applies to file
		switch (pkgType) {
			case PKG_SYSTEM:
				ret = tbChdir((unsigned long)(SYSTEM_PATH));
				break;		
	
			case PKG_USER:	
				strcpy(sTemp, USER_PATH);
				//strcat(sTemp,pkg->strHeapStack + pkg->idxName);
				ret = tbChdir((unsigned long)sTemp);
				break;
		}
	}
	if (getLastRecording)
		strcpy(sTemp,lastFilenameRecorded);
	else {
		strcpy(sTemp,pkg->strHeapStack + newFile->idxFilename);
		if (isPackageTitle)
			strcat(sTemp,AUDIO_TITLE_SUFFIX);
		strcat(sTemp,AUDIO_FILE_EXT);
	}
	ret = tbOpen((LPSTR)sTemp,O_RDWR);			
	return ret;
}

void play(CtnrFile *file, unsigned int startingPoint) {
	unsigned long l;
	
	l = extractTime(startingPoint, context.package->timePrecision);
	playLongInt(file,l);
}

static void playLongInt(CtnrFile *file, unsigned long lTimeNew) {
	// This fct is usually just called by play(), but is also used directly by insertSound()
	// so that a hyperlink sound can be inserted into playing audio and return as close as possible to
	// the last point played in the audio. 
	static int iFileHandle;
	unsigned long lTimeCurrent;
	long lDifference;
	unsigned long ulDifference;
	
	if (context.lastFile && (context.lastFile->idxFilename == file->idxFilename && SACM_Status())) {
		lTimeCurrent = Snd_A1800_GetCurrentTime();
		lDifference = lTimeNew - lTimeCurrent;
		if (lDifference >= 0)
			SACM_A1800FAT_SeekTime(lDifference,FORWARD_SKIP);
		else {
			ulDifference = (unsigned long)-lDifference;
			SACM_A1800FAT_SeekTime(ulDifference,BACKWARD_SKIP);
		}
		if (context.isPaused) {
			SACM_Resume();  // todo: is it better to resume and then seek?
			context.isPaused = FALSE;
		}
		if (GREEN_LED_WHEN_PLAYING)
			setLED(LED_GREEN,TRUE);
	} else {
		stop();
		close(iFileHandle);
		if (file->idxFilename != PKG_HEAP_SIZE)  // don't remember "stack-stored temp" pointers
			context.lastFile = file;  
		else
			context.lastFile = NULL; // to force to assume new file when going back to non-list file
		iFileHandle = getFileHandle(file);
		if (iFileHandle >= 0) {  //allows mistakes or dummy files to pass without problem
			SACMGet_A1800FAT_Mode(iFileHandle);
			Snd_SACM_PlayFAT(iFileHandle, C_CODEC_AUDIO1800);	
			SACM_Pause();
			SACM_A1800FAT_SeekTime(lTimeNew,FORWARD_SKIP);
			if (GREEN_LED_WHEN_PLAYING)
				setLED(LED_GREEN,TRUE);
			context.isStopped = FALSE;
		}
	}
	context.isPaused = FALSE;
	//TODO: jump to block from processButtonEvent info
}

void insertSound(CtnrFile *file, CtnrBlock *block, BOOL wait) {
	unsigned long lastPlayedPoint;
	CtnrFile *lastFilePlayed;
	unsigned long lBlockEndPoint;
	int keystroke = 0;
	int isPlayerStopped = !SACM_Status();
	BOOL wasPaused;
	
	wasPaused = context.isPaused;
	lastFilePlayed = context.file;
	context.file = file;
	if (block)
		lBlockEndPoint = extractTime(block->endTime,context.package->timePrecision);
	if (!isPlayerStopped) {
		lastPlayedPoint = Snd_A1800_GetCurrentTime();
		if (lastPlayedPoint < INSERT_SOUND_REWIND_MS)
			lastPlayedPoint = 0;
		else
			lastPlayedPoint -= INSERT_SOUND_REWIND_MS;
		//context.file should not be changed until we need them again in a few lines	
		play(context.file,block?block->startTime:0);
		context.isPaused = FALSE;
		while (SACM_Status() && !keystroke) {
			if (block && lBlockEndPoint < Snd_A1800_GetCurrentTime()) {
				stop();
			 	break;
			}
			if (!wait && (keystroke = keyCheck(0))) {
				context.keystroke = keystroke;
				if (keystroke == KEY_PLAY && !context.isPaused) {
					SACM_Pause();
					context.isPaused = TRUE;
				} else if (keystroke == KEY_PLAY && context.isPaused) {
					SACM_Resume();
					context.isPaused = FALSE;
				}
			}
		} 
		context.file = lastFilePlayed;
		playLongInt(context.file,lastPlayedPoint);
		if (wasPaused) {
			SACM_Pause();
			context.isPaused = TRUE;
		}
	}
	else {
		play(file,block?block->startTime:0);
		context.isPaused = FALSE;
		while (SACM_Status() && !keystroke) {
			if (block && lBlockEndPoint < Snd_A1800_GetCurrentTime()) {
				stop();
			 	break;
			}
			if (!wait && (keystroke = keyCheck(0))) {
				context.keystroke = keystroke;
				if (keystroke == KEY_PLAY && !context.isPaused) {
					SACM_Pause();
					context.isPaused = TRUE;
				} else if (keystroke == KEY_PLAY && context.isPaused) {
					SACM_Resume();
					context.isPaused = FALSE;
				}
			}
		}
		context.file = lastFilePlayed;
	}
	if (!SACM_Status()) {
		context.isStopped = TRUE;
		context.isPaused = FALSE;
	}
}

void insertSoundFile(int idxFile) {
	insertSound(&pkgSystem.files[idxFile],NULL,FALSE);
}
	
static int recordAudio(char *filename) {
	int i, handle, ret = -1;
	char temp[50];
	char filepath[60];
	long start, end;
	char *cursor;
	CtnrFile *file;
	ListItem *tempList;

	strcpy(filepath,USER_PATH);
	strcat(filepath,filename);
		
	i = context.package->idxMasterList;
	tempList = &pkgSystem.lists[i];
	cursor = getCurrentList(tempList);			
	file = getListFile(cursor,i);
	insertSound(file,NULL,TRUE);

	wait (100);
		
	start = getRTCinSeconds();
	longToDecimalString(start,temp,5);
	strcat((char *)temp,(const char *)": REC ");
	strcat((char *)temp,filename);
	logString(temp);
	insertSound(&pkgSystem.files[SPEAK_SOUND_FILE_IDX],NULL,TRUE);
	stop();
	setLED(LED_RED,TRUE);
	start = getRTCinSeconds();
	handle = tbOpen((LPSTR)filepath,O_CREAT|O_RDWR);
	if (handle != -1) {
		Snd_SACM_RecFAT(handle, C_CODEC_AUDIO1800, BIT_RATE);
		//longToDecimalString((long)*P_HQADC_MIC_PGA,&msgLog,2);
		//logString(&msgLog);
		waitForButton(0);  // triggers with any button press
		do
			end = getRTCinSeconds();
		while ((end - start) < 2);  // must be at least 1.0 second recording
		Snd_Stop(); // no need to call stop() and flush the log
		setLED(LED_RED,FALSE);
		close(handle);
		insertSound(&pkgSystem.files[BEEP_SOUND_FILE_IDX],NULL,TRUE); 
		//insertSound(file,NULL,TRUE);  // replay subject
		strcpy(lastFilenameRecorded,filename);
		longToDecimalString((long)end-start,temp,4);
		strcat((char *)temp,(const char *)" sec");
		logString(temp);
		strcpy(temp,USER_PATH); // necessary since dir changed with insertSound
		strcat(temp,filename);
		ret = fileExists((LPSTR)temp);
	} else {
		logException(16, filename,RESET);  //can't open file for new recording
	}
	return ret;
}	

int createRecording(char *pname, BOOL isTitle, int fromHeadphone) {
	char filename[40];
	int ret;
	int SPINS; //from page 102 of GPL Progammers Manual v1.0/Dec20,2006 
	           //headphone amp audio driver input source select 
	strcpy(filename,pname);
	if (fromHeadphone) {
		SPINS = 2;
		*P_HQADC_MIC_PGA &= 0xFFE0; // only first 5 bits for mic pre-gain; others reserved
		*P_HQADC_MIC_PGA |= MIC_GAIN_HEADPHONE;
	}
	else {
		SPINS = 0;
		if (MIC_GAIN_NORMAL >= 0) {
			*P_HQADC_MIC_PGA &= 0xFFE0; // only first 5 bits for mic pre-gain; others reserved
			*P_HQADC_MIC_PGA |= MIC_GAIN_NORMAL;
		}
	}	
	*P_HPAMP_Ctrl &= 0xFFF3; // zero bits 2 and 3
	if (SPINS) { // no point in ORing with nothing
		SPINS <<= 2; // move SPINS into bits 2 and 3 position
		*P_HPAMP_Ctrl |= SPINS;	
	}
/*	if (context.package->recInProgress) 
		getPkgNumber(filename,FALSE);  // gets current draft package number
	else {
		context.package->recInProgress = TRUE;
		getPkgNumber(filename,TRUE);  // gets next package number as new filename
	}
	if (isTitle) { // todo: fix this so it doesn't require that title is called first
		strcat(filename,AUDIO_TITLE_SUFFIX);
    }
*/
	strcat(filename,AUDIO_FILE_EXT);
	ret = recordAudio(filename);
	return ret;
}

